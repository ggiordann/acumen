import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import OpenAI from 'openai';
import { chromium } from 'playwright';
import dotenv from 'dotenv';
import path from 'path';
import { exec } from 'child_process';
import fs from 'fs';
import multer from 'multer';
import admin from "firebase-admin";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { Buffer } from "buffer";
import Stripe from 'stripe';

// IF ERROR REMOVE IMAGES UPLOAD

const __dirname = dirname(fileURLToPath(import.meta.url));

// Load environment variables
dotenv.config();

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// Initialize Firebase
const serviceAccount = JSON.parse(Buffer.from(process.env.FIREBASE_SECRETKEY_BASE64, "base64").toString("utf-8"));

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
});

const db = admin.firestore();

// Main Express app (port 1989)
const app = express();
const port = 1989; // Changed from 5500 to 1989

//initialise globals
var uid, email, fullName = null;

// Firebase auth middleware
async function verifyToken(req, res, next) {
    const idToken = req.headers.authorization?.split("Bearer ")[1];

    if (!idToken) {
        return res.status(401).send("Unauthorised");
    }

    try {
        const decodedToken = await admin.auth().verifyIdToken(idToken);
        req.user = decodedToken;
        console.log("token verified");
        next();
    } catch (error){
        res.status(401).send("Invalid Token");
        console.log(error);
    }
}

// Middleware setup
app.use(bodyParser.json({ limit: '25mb' }));
app.use(bodyParser.urlencoded({ limit: '25mb', extended: true }));
app.use(cors());
app.use(express.json());

// Around line 83 in server.js
app.use(express.static(path.join(process.cwd(), 'app'))); // comment out if not over network
app.use(express.static(path.join(process.cwd()))); // Serve files from project root


// File upload configuration
const uploadDir = path.join(process.cwd(), 'uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}

const storage = multer.diskStorage({
  destination: function(req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function(req, file, cb) {
    cb(null, Date.now() + '-' + file.originalname);
  }
});
const upload = multer({
  storage: storage,
  limits: { files: 10 }
});

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// ============== ENDPOINTS FROM SERVER.JS ==============

app.post('/upload', upload.array('files', 10), (req, res) => {
  res.json({ message: 'Files uploaded successfully', files: req.files });
});

app.post('/analyze', async (req, res) => {
  const { imageData } = req.body;
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'user',
          content: [
            { type: 'text', text: `
                Write a facebook marketplace Advertisement based on the product in the image.

                DO NOT USE ANY EMOJIS IN THE LISTING. DO NOT USE ANY SINGLE QUOTES IN THE DESCRIPTION, USE SOMETHING ELSE.

                Fill it out in JSON format with the following fields:
                - Title – a short, descriptive title for the listing.
                - Price – a price estimate for the product in AUD.
                - Category – choose the most suitable category from:
                  ["Tools", "Furniture", "Household", "Garden", "Appliances", 
                  "Video Games", "Books, Films & Music",
                  "Bags & Luggage", "Women's clothing & shoes", "Men's clothing & shoes", "Jewellery and accessories",
                  "Health & Beauty", "Pet supplies", "Baby & children", "Toys and games",
                  "Electronics & computers", "Mobile phones",
                  "Bicycles", "Arts & crafts", "Sport and outdoors", "Car parts", "Musical Instruments", "Antiques and collectibles",
                  "Garage sale", "Miscellaneous", "Vehicles"]
                - Condition – one of: ["New", "Used – like new", "Used – good", "Used – fair"]
                - Brand – the brand of the product (if applicable; leave blank if unknown)
                - Description – a detailed description of the product. At the end include a new line, and then "Generated by Acumen (acumen.ai)"
                - Availability – one of: ["List as single item", "List as in stock"]
                - Product Tags – a list of tags for the product.
                - Meetup Preferences – a list of meetup preferences, choose from: ["Public meetup", "Door pick-up", "Door drop-off"]
                - Hide from friends – a boolean value.

                OUTPUT RAW TEXT OUTPUT.

                EG.

                { "Title": "Casio FX-CG50 Graphing Calculator", "Price": 120, "Category": "Electronics & computers", "Condition": "Used – like new", "Brand": "Casio", "Description": "Lightly used Casio FX-CG50 graphing calculator in excellent condition. Perfect for students and professionals needing advanced calculation capabilities. Comes with original packaging, USB cable, and user manuals. Generated by Acumen (acumen.ai)", "Availability": "List as single item", "Product Tags": ["Calculator", "Graphing", "Casio", "FX-CG50", "Math"], "Meetup Preferences": ["Public meetup", "Door pick-up"], "Hide from friends": false }
                
                DO NOT SPECIFY IT IS A JSON WITH ANY EXTRA TEXT.
            ` },
            { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${imageData}` } }
          ]
        }
      ],
      max_tokens: 300
    });
    const answer = response.choices[0].message.content;
    res.json({ response: answer });
  } catch (error) {
    console.error('Error analyzing image:', error);
    res.status(500).json({ error: 'Error analyzing image' });
  }
});

app.post('/analyze-ebay', async (req, res) => {
  const { imageData } = req.body;
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'user',
          content: [
            { type: 'text', text: `
                    Write an eBay advertisement for the product in the image.

                    DO NOT USE ANY EMOJIS IN THE LISTING.

                    Fill it out in RAW JSON format with the following fields exactly:
                    - Title – a short, descriptive title for the listing.
                    - Price – a price estimate for the product in AUD.
                    - Condition for different Categories – one of:

                        For Calculators and Electronics:
                          ["Brand New", "New: Never Used", "Seller refurbished", "Used", "For parts or not working"].

                        For Hats:
                          ["New with tags", "New without tags", "New with defects", "Pre-Owned"].

                        For Shoes:
                          ["New with box", "New without box", "New with Imperfections", "Pre-owned"].

                        For Books:
                          ["Brand New", "Like New", "Very Good", "Good", "Acceptable"].

                        For Clothing:
                          ["New with tags", "New without tags", "New with defects", "Pre-Owned"].

                        For Video Games:
                          ["Brand New", "New: Never Used", "Used", "For parts or not working"].

                        For Watches:
                          ["Brand New", "Pre-owned", "Certified Pre-owned", "For parts or not working"].

                        For Furniture:
                          ["New", "Used"].

                        For Collectibles:
                          ["Brand New", "Used", "For parts or not working"].

                    - Description – a detailed description of the product in HTML formatting (use <br> for line breaks). End with a new line and then "Generated by Acumen (acumen.ai)".
                    - SearchTerm – a concise term to be used for searching the product on eBay.

                    EG.

                    { "Title": "Casio FX-CG50 Calculator", "Price": 99.99, "Condition": "Used", "Description": "Lightly used Casio FX-CG50 calculator in good working condition.<br>Perfect for students and professionals.<br>Generated by Acumen (acumen.ai)", "SearchTerm": "Casio FX-CG50 Calculator" }

                    DO NOT SPECIFY IT IS A JSON WITH ANY EXTRA TEXT EG DO NOT SAY "JSON Grave (DASH) Grave (DASH) Grave (DASH)" AND THEN THE JSON. JUST OUTPUT RAW JSON AS TEXT.
                    
                    LIKE THIS:

                    {"Title": "Casio FX-CG50 Calculator with Accessories", "Price": 120.00, "Condition": "Used", "Description": "Casio FX-CG50 calculator in good condition, includes original packaging and manuals.<br>Comes with cables and protective cover.<br>Ideal for students and professionals seeking a reliable graphing calculator.<br>Generated by Acumen (acumen.ai)", "SearchTerm": "Casio FX-CG50 Calculator" }

                    SEE, NO DASHES. DO NOT INCLUDE ´´´ JSON OR I WILL TERMINATE YOU

                    DO NOT INCLUDE ANY ADDITIONAL TEXT. CONDITION SHOULD BE THE EXACT SAME TEXT AS CONDITIONS FROM THE ARRAY STATES ABOVE.
            ` },
            { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${imageData}` } }
          ]
        }
      ],
      max_tokens: 300
    });
    const answer = response.choices[0].message.content;
    res.json({ response: answer });
  } catch (error) {
    console.error('Error analyzing image for eBay:', error);
    res.status(500).json({ error: 'Error analyzing image for eBay' });
  }
});

app.post('/post-facebook', async (req, res) => {
  const adData = req.body;
  try {
    const adDataStr = JSON.stringify(adData);
    exec(`node fb_post.spec.js '${adDataStr}'`, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error executing fb_post.spec.js: ${error}`);
        return res.status(500).json({ error: stderr });
      }
      return res.json({ message: stdout });
    });
  } catch (error) {
    console.error('Error posting Facebook listing:', error);
    res.status(500).json({ error: error.toString() });
  }
});

app.post('/post-ebay', async (req, res) => {
  const adData = req.body;
  try {
    const adDataStr = JSON.stringify(adData);
    exec(`node ebay_post.spec.js '${adDataStr}'`, (error, stdout, stderr) => {
      if (error) {
         console.error(`Error executing ebay_post.spec.js: ${error}`);
         return res.status(500).send(stderr);
      }
      return res.send(stdout);
    });
  } catch (error) {
    console.error('Error posting eBay listing:', error);
    res.status(500).json({ error: error.toString() });
  }
});

app.get('/run-fb-login', (req, res) => {
  exec('node fb_login.spec.js', (error, stdout, stderr) => {
    if (error) {
      console.error(`Error executing fb_login.spec.js: ${error}`);
      return res.status(500).send(stderr);
    }
    res.send(stdout);
  });
});

app.get('/run-ebay-login', (req, res) => {
  exec('node ebay_login.spec.js', (error, stdout, stderr) => {
    if (error) {
      console.error(`Error executing ebay_login.spec.js: ${error}`);
      return res.status(500).send(stderr);
    }
    res.send(stdout);
  });
});

// ============== ENDPOINTS FROM SUBSERVER.JS ==============

app.post("/save-user", verifyToken, async (req, res) => {
    ({ uid, email, fullName } = req.user);

    if (!uid) {
        return res.status(400).json({ error: "Invalid request: UID is missing" });
    }

    try {
        console.log("Db thing trying");
        const userDocRef = db.collection('users').doc(uid);
        const userDoc = await userDocRef.get();

        console.log("Db thing done");

        if (!userDoc.exists) {
            console.log("New user detected, saving to Firestore...");
             
            // Create a Stripe customer for the new user
            let stripeCustomerId = null;
            try {
                const customer = await stripe.customers.create({
                    email: email,
                    name: fullName || "Unknown",
                    metadata: {
                        firebaseUID: uid
                    }
                });
                stripeCustomerId = customer.id;
                console.log(`Created Stripe customer: ${stripeCustomerId} for user: ${uid}`);
            } catch (stripeError) {
                console.error("Error creating Stripe customer:", stripeError);
                // Continue even if Stripe customer creation fails
            }
            
            // Save new user to Firestore with Stripe customer ID
            await userDocRef.set({
                email,
                name: fullName || "Unknown", // If Google OAuth doesn't return a name
                createdAt: new Date(),
                stripeCustomerId: stripeCustomerId,
                subscription: {
                  subscriptionLevel:"free",
                  status: "none",
                  updatedAt: admin.firestore.FieldValue.serverTimestamp(),
                },
            });
            return res.json({ message: "New user created", email, uid });
        }

        console.log("Existing user Logged in");
        return res.json({ message: "Existing user", email, uid });

    } catch (error) {
        console.log("Error: " + error.message);
        res.status(500).send(error.message);
    }
});

app.get("/get-api-key", async(req, res) => {
    console.log("Firebase config sent");
    try {
        const firebaseConfigString = process.env.FIREBASE_API.replace(/'/g, '"');
        const firebaseConfig = JSON.parse(firebaseConfigString);
        res.json({ firebaseConfig: firebaseConfig });
    } catch (error) {
        console.error("Error with Firebase config:", error);
        res.status(500).send("Error with Firebase configuration");
    }
});

app.get("/get-user-id", async (req, res) => {
    res.json({ userId: uid });
})

// =============== STRIPE ENDPOINTS ===============

// Create checkout session endpoint
app.post('/create-checkout-session', async (req, res) => {
  const { plan, uid } = req.body;

  console.log(`Creating checkout session for user ${uid}, plan: ${plan}`);

  //get user from firestore
  const userRef = db.collection('users').doc(uid);
  const userDoc = await userRef.get();
  
  //just in case user doesn't exist
  if (!userDoc.exists) {
    return res.status(404).json({ error: 'User not found' });
  }

  const userData = userDoc.data();
  const { email, name } = userData;
  const currentPlan = userData.subscription?.subscriptionLevel || 'free';
  
  console.log(`User current plan: ${currentPlan}, upgrading to: ${plan}`);

  // Map plan names to price IDs
  const priceIds = {
    plus: 'price_1R4Az1IMPfgQ2CBGgRnSEebU',
    pro: 'price_1R4AzuIMPfgQ2CBGakghtEhV',
    premium: 'price_1R4B0WIMPfgQ2CBGJSZnF7oJ'
  };
  
  console.log(process.env.STRIPE_SECRET_KEY);

  try {
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [
        {
          price: priceIds[plan],
          quantity: 1,
        },
      ],
      customer_email: email,
      mode: 'subscription',
      success_url: `http://localhost:5501/acumen-1/membership_pages/success.html?session_id={CHECKOUT_SESSION_ID}&plan=${plan}`,
      cancel_url: `http://localhost:5501/acumen-1/membership_pages/subscription.html`,
      client_reference_id: req.body.userId, // Add user ID for webhook
      metadata: {
        plan: plan,
        userId: uid,
        name: name,
        previousPlan: currentPlan,
        isUpgrade: currentPlan !== plan ? 'true' : 'false'
      }
    });

    res.json({ id: session.id, url: session.url });
  } catch (error) {
    console.error('Error creating checkout session:', error);
    res.status(500).json({ error: error.message });
  }
});

//when customer clicks cancel subscription button. 
//rn it instantly deletes for testing but later we can make it end at period end
app.post('/cancel-subscription', async (req, res) => {
  const { uid } = req.body; // 'uid' is the user's Firebase ID

  try {
    // Look up the user in Firestore
    const userDoc = await db.collection('users').doc(uid).get();
    if (!userDoc.exists) {
      return res.status(404).send({ error: 'User not found' });
    }
    
    const userData = userDoc.data();
    const subscriptionId = userData.subscription?.id;
    
    if (!subscriptionId) {
      return res.status(400).send({ error: 'No active subscription found' });
    }
    
    // Cancel the subscription in Stripe
    const result = await stripe.subscriptions.cancel(subscriptionId);
    
    // Update the user's subscription status in Firestore
    await db.collection('users').doc(uid).update({
      subscription: {
        subscriptionLevel: "free",
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        status: "cancelled"
      }
    });

    return res.status(200).send({ success: true, message: 'Subscription cancelled' });
  } catch (error) {
    console.error('Error canceling subscription:', error);
    return res.status(500).send({ error: 'Internal server error' });
  }
})

// Stripe webhook endpoint to handle subscription events
app.post('/webhook', bodyParser.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  let event;

  try {
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Handle the event
  switch (event.type) {
    // Handle checkout session completion
    case 'checkout.session.completed':
      const session = event.data.object;
      // Extract metadata from the session
      const { userId, plan } = session.metadata || {};
      console.log(`Checkout session completed for user ${userId}, plan: ${plan}`);
      
      if (userId) {
        // Get or create Stripe customer
        let customerId = session.customer;
        let subscriptionId = session.subscription;
        
        if (customerId && subscriptionId) {
          try {
            // Update the user's Firestore document with Stripe customer ID and subscription details
            await db.collection('users').doc(userId).update({
              stripeCustomerId: customerId,
              subscription: {
                id: subscriptionId,
                subscriptionLevel: plan,
                status: 'active',
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              }
            });
            console.log(`Updated user ${userId} with subscription ${subscriptionId}`);
          } catch (error) {
            console.error(`Error updating user ${userId}:`, error);
          }
        }
      }
      break;
      
    // Handle subscription updates  
    case 'customer.subscription.updated':
      const subscription = event.data.object;
      const customerId = subscription.customer;
      
      // Get subscription details including the plan
      try {
        const subscriptionData = await stripe.subscriptions.retrieve(subscription.id);
        const planId = subscriptionData.items.data[0].plan.id;
        
        // Map plan ID to plan name
        let planName = "free";
        if (planId === 'price_1R4Az1IMPfgQ2CBGgRnSEebU') planName = "plus";
        else if (planId === 'price_1R4AzuIMPfgQ2CBGakghtEhV') planName = "pro";
        else if (planId === 'price_1R4B0WIMPfgQ2CBGJSZnF7oJ') planName = "premium";
        
        // Find users with this Stripe customer ID
        const usersSnapshot = await db.collection('users')
          .where('stripeCustomerId', '==', customerId)
          .get();
          
        if (!usersSnapshot.empty) {
          usersSnapshot.forEach(doc => {
            doc.ref.update({
              subscription: {
                id: subscription.id,
                subscriptionLevel: planName,
                status: subscription.status,
                periodStart: subscription.current_period_start,
                periodEnd: subscription.current_period_end,
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              }
            });
            console.log(`Updated subscription for user ${doc.id} to ${planName}`);
          });
        }
      } catch (error) {
        console.error('Error processing subscription update:', error);
      }
      break;
    
    //Handle invoice payments  
    case 'invoice.paid':
      var invoice = event.data.object;
      var subscriptionId = invoice.subscription;

      updateCustomerSubscription(invoice.customer, subscriptionId, invoice);
      break;
      
    case 'customer.subscription.deleted':
      const deletedSubscription = event.data.object;
      updateCustomerSubscription(deletedSubscription.customer, deletedSubscription.id, "cancelled");
      break;
      
    case 'invoice.payment_failed':
      var failedInvoice = event.data.object;
      var failedSubscriptionId = failedInvoice.subscription;

      updateCustomerSubscription(failedInvoice.customer, failedSubscriptionId, "cancelled");
      break;
  }

  // Return a 200 response to acknowledge receipt of the event
  res.send();
});

// Verify a Stripe session status directly
app.get('/verify-session', verifyToken, async (req, res) => {
  try {
    const { session_id } = req.query;
    
    if (!session_id) {
      return res.status(400).json({ error: 'Missing session_id parameter' });
    }
    
    console.log(`Verifying Stripe session ${session_id}`);
    
    // Get the session from Stripe
    const session = await stripe.checkout.sessions.retrieve(session_id);
    
    // Check payment status
    const isComplete = session && session.payment_status === 'paid';
    const customerId = session.customer;
    const subscriptionId = session.subscription;
    const metadata = session.metadata || {};
    
    console.log(`Session verification: payment_status=${session.payment_status}, customer=${customerId}, subscription=${subscriptionId}`);
    
    if (isComplete && subscriptionId) {
      // Get subscription details
      const subscription = await stripe.subscriptions.retrieve(subscriptionId);
      
      // Get the plan ID and map to plan name
      const planId = subscription.items.data[0].plan.id;
      let planName = "free";
      
      if (planId === 'price_1R4Az1IMPfgQ2CBGgRnSEebU') planName = "plus";
      else if (planId === 'price_1R4AzuIMPfgQ2CBGakghtEhV') planName = "pro";
      else if (planId === 'price_1R4B0WIMPfgQ2CBGJSZnF7oJ') planName = "premium";
      
      console.log(`Subscription plan: ${planName}`);
      
      // Check if user ID in request matches the one in session metadata
      const userId = metadata.userId || req.user.uid;
      
      if (userId) {
        // Update the user's Firestore document
        await db.collection('users').doc(userId).update({
          stripeCustomerId: customerId,
          subscription: {
            id: subscriptionId,
            subscriptionLevel: planName,
            status: subscription.status,
            periodStart: subscription.current_period_start,
            periodEnd: subscription.current_period_end,
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          }
        });
        
        console.log(`Updated user ${userId} with subscription ${subscriptionId}`);
        return res.json({ 
          verified: true, 
          plan: planName, 
          status: subscription.status 
        });
      }
    }
    
    return res.json({ 
      verified: isComplete, 
      metadata: metadata 
    });
    
  } catch (error) {
    console.error('Error verifying session:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Force update a user's subscription based on session ID
app.post('/force-update-subscription', verifyToken, async (req, res) => {
  try {
    const { uid, session_id, plan } = req.body;
    
    // Make sure this is the same user making the request or an admin
    if (uid !== req.user.uid) {
      return res.status(403).json({ error: 'Unauthorized access' });
    }
    
    console.log(`Force updating subscription for user ${uid} to plan ${plan}`);
    
    // Get user data
    const userDoc = await db.collection('users').doc(uid).get();
    if (!userDoc.exists) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const userData = userDoc.data();
    const stripeCustomerId = userData.stripeCustomerId;
    
    if (!stripeCustomerId) {
      console.error("No Stripe customer ID for user");
      return res.status(400).json({ error: 'No Stripe customer ID for user' });
    }
    
    let subscriptionId = null;
    
    // If we have a session ID, try to get subscription from it
    if (session_id) {
      try {
        const session = await stripe.checkout.sessions.retrieve(session_id);
        subscriptionId = session.subscription;
        console.log(`Retrieved subscription ID ${subscriptionId} from session ${session_id}`);
      } catch (stripeError) {
        console.error("Error retrieving session from Stripe:", stripeError);
      }
    }
    
    // If no subscription ID from session, try to create/update via Stripe API
    if (!subscriptionId) {
      try {
        // Check if user already has a subscription
        const existingSubscriptions = await stripe.subscriptions.list({
          customer: stripeCustomerId,
          limit: 1,
          status: 'all'
        });
        
        if (existingSubscriptions.data.length > 0) {
          // Update existing subscription
          const existingSubscription = existingSubscriptions.data[0];
          subscriptionId = existingSubscription.id;
          
          console.log(`Found existing subscription ${subscriptionId} for customer ${stripeCustomerId}`);
          
          // If subscription is canceled, create a new one instead
          if (existingSubscription.status === 'canceled') {
            console.log("Existing subscription is canceled, creating new one");
            subscriptionId = null;
          }
        }
        
        // Map plan to price ID
        const priceIds = {
          plus: 'price_1R4Az1IMPfgQ2CBGgRnSEebU',
          pro: 'price_1R4AzuIMPfgQ2CBGakghtEhV',
          premium: 'price_1R4B0WIMPfgQ2CBGJSZnF7oJ'
        };
        
        const priceId = priceIds[plan] || priceIds.plus;
        
        if (!subscriptionId) {
          // Create new subscription
          const newSubscription = await stripe.subscriptions.create({
            customer: stripeCustomerId,
            items: [{ price: priceId }],
            metadata: {
              firebaseUID: uid
            }
          });
          
          subscriptionId = newSubscription.id;
          console.log(`Created new subscription ${subscriptionId} for customer ${stripeCustomerId}`);
        } else {
          // Update existing subscription
          const updatedSubscription = await stripe.subscriptions.update(subscriptionId, {
            items: [{
              id: existingSubscriptions.data[0].items.data[0].id,
              price: priceId
            }],
            metadata: {
              firebaseUID: uid
            }
          });
          
          console.log(`Updated subscription ${subscriptionId} for customer ${stripeCustomerId}`);
        }
      } catch (stripeError) {
        console.error("Error updating subscription via Stripe API:", stripeError);
      }
    }
    
    // Update user document in Firestore
    await db.collection('users').doc(uid).update({
      subscription: {
        id: subscriptionId,
        subscriptionLevel: plan,
        status: 'active',
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }
    });
    
    console.log(`Force updated user ${uid} subscription in Firestore to ${plan}`);
    
    return res.json({
      success: true,
      plan: plan,
      subscriptionId: subscriptionId || 'manual-update'
    });
    
  } catch (error) {
    console.error('Error forcing subscription update:', error);
    return res.status(500).json({ error: 'Internal server error', message: error.message });
  }
});

//multiple use function to update user subscription
async function updateCustomerSubscription(customerId, subscriptionId, invoice) {
  try {
    // Query Firestore for users with this stripeCustomerId
    const usersSnapshot = await db.collection('users')
      .where('stripeCustomerId', '==', customerId)
      .get();

    if (usersSnapshot.empty) {
      console.log(`No user found with stripeCustomerId: ${customerId}`);
      return;
    }

    let subscriptionData;
    
    // If there is invoice, update/add subscription, otherwise cancel plan
    if (invoice !== "cancelled") {
      // Get subscription details from Stripe
      const subscription = await stripe.subscriptions.retrieve(subscriptionId);
      const planId = subscription.items.data[0].plan.id;
      
      // Map plan ID to plan name
      let planName = "free";
      if (planId === 'price_1R4Az1IMPfgQ2CBGgRnSEebU') planName = "plus";
      else if (planId === 'price_1R4AzuIMPfgQ2CBGakghtEhV') planName = "pro";
      else if (planId === 'price_1R4B0WIMPfgQ2CBGJSZnF7oJ') planName = "premium";
      
      subscriptionData = {
        id: subscriptionId,
        subscriptionLevel: planName,
        periodStart: subscription.current_period_start,
        periodEnd: subscription.current_period_end,
        status: subscription.status,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };
    } else {
      subscriptionData = {
        subscriptionLevel: "free",
        status: "cancelled",
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };
    }

    // Update for every matching user
    usersSnapshot.forEach(doc => {
      doc.ref.update({
        subscription: subscriptionData
      });
      console.log(`Updated subscription for user ${doc.id}`);
    });
  } catch (error) {
    console.error('Error updating user subscription:', error);
  }
}

// Get user subscription endpoint
app.get('/get-user-subscription', verifyToken, async (req, res) => {
  try {
    const { uid } = req.query;
    
    // Make sure this is the same user making the request
    if (uid !== req.user.uid) {
      return res.status(403).json({ error: 'Unauthorized access to subscription data' });
    }
    
    // Get user data from Firestore
    const userDoc = await db.collection('users').doc(uid).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const userData = userDoc.data();
    
    // Return subscription data
    return res.json({ 
      subscription: userData.subscription || { subscriptionLevel: 'free' }
    });
  } catch (error) {
    console.error('Error getting user subscription:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Start the server on port 1989
app.listen(port, '0.0.0.0', () => {
  console.log(`Server listening on port ${port}`);
});